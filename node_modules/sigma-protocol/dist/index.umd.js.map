{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import axios from \"axios\";\r\nimport {\r\n  BSM,\r\n  Hash,\r\n  P2PKHAddress,\r\n  PrivateKey,\r\n  Script,\r\n  Signature,\r\n  Transaction,\r\n  TxOut,\r\n} from \"bsv-wasm\";\r\nimport { Buffer } from \"buffer\";\r\nexport type AuthToken = {\r\n  type: \"header\" | \"query\";\r\n  value: string;\r\n  key: string;\r\n};\r\n\r\nexport type RemoteSigningResponse = {\r\n  address: string;\r\n  sig: string;\r\n  message: string;\r\n  ts: number;\r\n};\r\n\r\nexport const sigmaHex = \"5349474d41\";\r\nexport enum Algorithm {\r\n  \"BSM\" = \"BSM\",\r\n}\r\n\r\nexport type Sig = {\r\n  address: string;\r\n  signature: string;\r\n  algorithm: Algorithm;\r\n  vin: number;\r\n  targetVout: number;\r\n};\r\n\r\nexport interface SignResponse extends Sig {\r\n  sigmaScript: Script;\r\n  signedTx: Transaction;\r\n}\r\n\r\nexport class Sigma {\r\n  private _inputHash: Hash | null = null;\r\n  private _dataHash: Hash | null = null;\r\n  private _transaction: Transaction;\r\n  private _sigmaInstance: number;\r\n  private _refVin: number;\r\n  private _targetVout: number;\r\n  private _sig: Sig | null;\r\n\r\n  constructor(\r\n    transaction: Transaction,\r\n    targetVout: number = 0,\r\n    sigmaInstance: number = 0,\r\n    refVin: number = 0\r\n  ) {\r\n    this._transaction = transaction;\r\n    this._targetVout = targetVout;\r\n    this._refVin = refVin;\r\n    this._sigmaInstance = sigmaInstance;\r\n    this._sig = this.sig;\r\n    this.setHashes();\r\n  }\r\n\r\n  setHashes = () => {\r\n    this._inputHash = this.getInputHash();\r\n    this._dataHash = this.getDataHash();\r\n  };\r\n\r\n  setTargetVout = (targetVout: number) => {\r\n    this._targetVout = targetVout;\r\n  };\r\n\r\n  setSigmaInstance = (sigmaInstance: number) => {\r\n    this._sigmaInstance = sigmaInstance;\r\n  };\r\n\r\n  getMessageHash(): Hash {\r\n    if (!this._inputHash || !this._dataHash) {\r\n      throw new Error(\"Input hash and data hash must be set\");\r\n    }\r\n\r\n    const inputBytes = this._inputHash.to_bytes();\r\n    const dataBytes = this._dataHash.to_bytes();\r\n    const combinedHashes = new Uint8Array(inputBytes.length + dataBytes.length);\r\n    combinedHashes.set(inputBytes, 0);\r\n    combinedHashes.set(dataBytes, inputBytes.length);\r\n\r\n    return Hash.sha_256(combinedHashes);\r\n  }\r\n\r\n  get transaction(): Transaction {\r\n    return this._transaction;\r\n  }\r\n\r\n  _sign(signature: Signature, address: string) {\r\n    const vin = this._refVin === -1 ? this._targetVout : this._refVin;\r\n    const signedAsm = `${sigmaHex} ${Buffer.from(\r\n      Algorithm.BSM,\r\n      \"utf-8\"\r\n    ).toString(\"hex\")} ${Buffer.from(address, \"utf-8\").toString(\r\n      \"hex\"\r\n    )} ${signature.to_compact_hex()} ${Buffer.from(\r\n      vin.toString(),\r\n      \"utf-8\"\r\n    ).toString(\"hex\")}`;\r\n\r\n    const sigmaScript = Script.from_asm_string(signedAsm);\r\n\r\n    this._sig = {\r\n      algorithm: Algorithm.BSM,\r\n      address: address,\r\n      signature: Buffer.from(signature.to_compact_bytes()).toString(\"base64\"),\r\n      vin,\r\n      targetVout: this._targetVout,\r\n    };\r\n\r\n    let existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const containsOpReturn = existingAsm?.split(\" \").includes(\"OP_RETURN\");\r\n    const separator = containsOpReturn ? \"7c\" : \"OP_RETURN\";\r\n\r\n    let newScriptAsm = \"\";\r\n\r\n    const existingSig = this.sig;\r\n\r\n    // sigmaIndex is 0 based while count is 1 based\r\n    if (existingSig && this._sigmaInstance === this.getSigInstanceCount()) {\r\n      // Replace the existing signature\r\n      const scriptChunks = existingAsm?.split(\" \") || [];\r\n      const sigIndex = this.getSigInstancePosition();\r\n\r\n      const newSignedAsmChunks = signedAsm.split(\" \");\r\n      if (sigIndex !== -1) {\r\n        existingAsm = scriptChunks\r\n          .splice(sigIndex, 5, ...newSignedAsmChunks)\r\n          .join(\"\");\r\n      }\r\n    }\r\n    // Append the new signature\r\n    newScriptAsm = `${existingAsm} ${separator} ${signedAsm}`;\r\n\r\n    const newScript = Script.from_asm_string(newScriptAsm);\r\n    const signedTx = Transaction.from_bytes(this._transaction.to_bytes());\r\n    const signedTxOut = new TxOut(this.targetTxOut!.get_satoshis(), newScript);\r\n    signedTx.set_output(this._targetVout, signedTxOut);\r\n\r\n    // update the object state\r\n    this._transaction = signedTx;\r\n\r\n    return {\r\n      sigmaScript,\r\n      signedTx,\r\n      ...this._sig,\r\n    };\r\n  }\r\n  // Sign with Sigma protocol\r\n  // privateKey: a bsv-wasm PrivateKey\r\n  // inputs: either an array of TxIn from bsv-wasm or an array o string txids\r\n  //    must be in the same order they are added to the transaction\r\n  //    adding input txids to the signature scheme eliminates replay attacks\r\n  // dataHash: a sha256 hash of the data to be signed\r\n  //     it should include all the data in the output script prior to the \"SIGMA\" protocol instance\r\n  //     excluding the \"|\" protocol separator and \"SIGMA\" prefix itself\r\n  sign(privateKey: PrivateKey): SignResponse {\r\n    const message = this.getMessageHash();\r\n\r\n    let signature = BSM.sign_message(privateKey, message.to_bytes());\r\n\r\n    const address = P2PKHAddress.from_pubkey(\r\n      privateKey.to_public_key()\r\n    ).to_string();\r\n\r\n    return this._sign(signature, address);\r\n  }\r\n\r\n  async remoteSign(\r\n    keyHost: string,\r\n    authToken?: AuthToken\r\n  ): Promise<SignResponse> {\r\n    const headers = authToken\r\n      ? {\r\n          [authToken?.key]: authToken?.value,\r\n        }\r\n      : {};\r\n\r\n    try {\r\n      const response = await axios.post(\r\n        `${keyHost}/sign${\r\n          authToken?.type === \"query\"\r\n            ? \"?\" + authToken?.key + \"=\" + authToken?.value\r\n            : \"\"\r\n        }`,\r\n        {\r\n          message: this.getMessageHash().to_hex(),\r\n          encoding: \"hex\",\r\n        },\r\n        {\r\n          headers: {\r\n            ...headers,\r\n            \"Content-Type\": \"application/json\",\r\n            Accept: \"application/json\",\r\n          },\r\n        }\r\n      );\r\n      const { address, message, sig } = response.data as RemoteSigningResponse;\r\n\r\n      const signature = Signature.from_compact_bytes(\r\n        Buffer.from(sig, \"base64\")\r\n      );\r\n      return this._sign(signature, address);\r\n    } catch (error: any) {\r\n      console.log(error);\r\n      // handle error\r\n      throw new Error(error.response);\r\n    }\r\n  }\r\n\r\n  verify = () => {\r\n    if (!this.sig) {\r\n      throw new Error(\"No signature data provided\");\r\n    }\r\n    if (!this.getMessageHash()) {\r\n      throw new Error(\"No tx data provided\");\r\n    }\r\n\r\n    const p2pkhAddress = P2PKHAddress.from_string(this.sig.address);\r\n    const signature = Signature.from_compact_bytes(\r\n      Buffer.from(this.sig.signature, \"base64\")\r\n    );\r\n\r\n    return p2pkhAddress.verify_bitcoin_message(\r\n      this.getMessageHash().to_bytes(),\r\n      signature\r\n    );\r\n  };\r\n\r\n  getInputHash = (): Hash => {\r\n    // if vin is -1, we're signing the corresponding input\r\n    // so we use this._targetVout as the vin\r\n    // this allows for better compatibility with partially signed transactions\r\n    // where the anchor input index is not known\r\n    const vin = this._refVin === -1 ? this._targetVout : this._refVin;\r\n    return this._getInputHashByVin(vin);\r\n  };\r\n\r\n  private _getInputHashByVin = (vin: number): Hash => {\r\n    const txIn = this._transaction.get_input(vin);\r\n    if (txIn) {\r\n      return Hash.sha_256(txIn.get_outpoint_bytes());\r\n    }\r\n    // using dummy hash\r\n    return Hash.sha_256(new Uint8Array(32));\r\n  };\r\n\r\n  // gets the Hash.sha256 for a given sigma instance within an output script\r\n  // an example of 2 instances would be a user signature followed by a platform signature\r\n  getDataHash = (): Hash => {\r\n    if (!this._transaction) {\r\n      throw new Error(\"No transaction provided\");\r\n    }\r\n    const outputScript = this._transaction\r\n      ?.get_output(this._targetVout)\r\n      ?.get_script_pub_key();\r\n\r\n    const scriptChunks = outputScript?.to_asm_string().split(\" \") || [];\r\n\r\n    // loop over the script chunks and set the endIndex when the nTh instance is found\r\n    let occurances = 0;\r\n    for (let i = 0; i < scriptChunks.length; i++) {\r\n      if (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\r\n        if (occurances === this._sigmaInstance) {\r\n          // the -1 is to account for either the OP_RETURN\r\n          // or \"|\" separator which is not signed\r\n          const dataChunks = scriptChunks.slice(0, i - 1);\r\n          const dataScript = Script.from_asm_string(dataChunks.join(\" \"));\r\n          return Hash.sha_256(dataScript.to_bytes());\r\n        }\r\n        occurances++;\r\n      }\r\n    }\r\n\r\n    // If no endIndex found, return the hash for the entire script\r\n    const dataScript = Script.from_asm_string(scriptChunks.join(\" \"));\r\n    return Hash.sha_256(dataScript.to_bytes());\r\n  };\r\n\r\n  get targetTxOut(): TxOut | null {\r\n    return this._transaction?.get_output(this._targetVout) || null;\r\n  }\r\n\r\n  // get the signature from the selected sigma instance\r\n  get sig(): Sig | null {\r\n    const output = this._transaction.get_output(this._targetVout);\r\n    const outputScript = output?.get_script_pub_key();\r\n\r\n    const scriptChunks = outputScript?.to_asm_string().split(\" \") || [];\r\n    const instances: Sig[] = [];\r\n\r\n    for (let i = 0; i < scriptChunks.length; i++) {\r\n      if (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\r\n        const sig = {\r\n          algorithm: Buffer.from(scriptChunks[i + 1], \"hex\").toString(\"utf-8\"),\r\n          address: Buffer.from(scriptChunks[i + 2], \"hex\").toString(\"utf-8\"),\r\n          signature: Buffer.from(scriptChunks[i + 3], \"hex\").toString(\"base64\"),\r\n          vin: parseInt(\r\n            Buffer.from(scriptChunks[i + 4], \"hex\").toString(\"utf-8\")\r\n          ),\r\n        } as Sig;\r\n\r\n        instances.push(sig);\r\n\r\n        // fast forward to the next possible instance position\r\n        // 3 fields + 1 extra for the \"|\" separator\r\n        i += 4;\r\n      }\r\n    }\r\n    return instances.length === 0 ? this._sig : instances[this._sigmaInstance];\r\n  }\r\n\r\n  getSigInstanceCount(): number {\r\n    const existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const scriptChunks = existingAsm?.split(\" \") || [];\r\n    return scriptChunks.filter(\r\n      (chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase()\r\n    ).length;\r\n  }\r\n\r\n  getSigInstancePosition(): number {\r\n    const existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const scriptChunks = existingAsm?.split(\" \") || [];\r\n    return scriptChunks.findIndex(\r\n      (chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase()\r\n    );\r\n  }\r\n}\r\n"],"names":["sigmaHex","Algorithm","Sigma","transaction","targetVout","sigmaInstance","refVin","_this","this","_inputHash","_dataHash","_transaction","_sigmaInstance","_refVin","_targetVout","_sig","setHashes","getInputHash","getDataHash","setTargetVout","setSigmaInstance","verify","sig","Error","getMessageHash","p2pkhAddress","P2PKHAddress","from_string","address","signature","Signature","from_compact_bytes","Buffer","from","verify_bitcoin_message","to_bytes","_getInputHashByVin","vin","txIn","get_input","Hash","sha_256","get_outpoint_bytes","Uint8Array","_this$_transaction","_this$_transaction$ge","outputScript","get_output","get_script_pub_key","scriptChunks","to_asm_string","split","occurances","i","length","toUpperCase","dataChunks","slice","dataScript","Script","from_asm_string","join","_proto","prototype","inputBytes","dataBytes","combinedHashes","set","_sign","_this$targetTxOut","_existingAsm","signedAsm","BSM","toString","to_compact_hex","sigmaScript","algorithm","to_compact_bytes","existingAsm","targetTxOut","separator","includes","getSigInstanceCount","_existingAsm2","sigIndex","getSigInstancePosition","newSignedAsmChunks","splice","apply","concat","newScript","signedTx","Transaction","from_bytes","signedTxOut","TxOut","get_satoshis","set_output","_extends","sign","privateKey","message","sign_message","from_pubkey","to_public_key","to_string","remoteSign","keyHost","authToken","_ref","_this2","headers","key","value","Promise","resolve","axios","post","type","to_hex","encoding","Accept","then","response","_response$data","data","_catch","error","console","log","e","reject","_this$targetTxOut2","filter","chunk","_this$targetTxOut3","findIndex","get","_this$_transaction2","output","instances","parseInt","push"],"mappings":"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"}