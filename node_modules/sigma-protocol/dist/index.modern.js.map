{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import axios from \"axios\";\r\nimport {\r\n  BSM,\r\n  Hash,\r\n  P2PKHAddress,\r\n  PrivateKey,\r\n  Script,\r\n  Signature,\r\n  Transaction,\r\n  TxOut,\r\n} from \"bsv-wasm\";\r\nimport { Buffer } from \"buffer\";\r\nexport type AuthToken = {\r\n  type: \"header\" | \"query\";\r\n  value: string;\r\n  key: string;\r\n};\r\n\r\nexport type RemoteSigningResponse = {\r\n  address: string;\r\n  sig: string;\r\n  message: string;\r\n  ts: number;\r\n};\r\n\r\nexport const sigmaHex = \"5349474d41\";\r\nexport enum Algorithm {\r\n  \"BSM\" = \"BSM\",\r\n}\r\n\r\nexport type Sig = {\r\n  address: string;\r\n  signature: string;\r\n  algorithm: Algorithm;\r\n  vin: number;\r\n  targetVout: number;\r\n};\r\n\r\nexport interface SignResponse extends Sig {\r\n  sigmaScript: Script;\r\n  signedTx: Transaction;\r\n}\r\n\r\nexport class Sigma {\r\n  private _inputHash: Hash | null = null;\r\n  private _dataHash: Hash | null = null;\r\n  private _transaction: Transaction;\r\n  private _sigmaInstance: number;\r\n  private _refVin: number;\r\n  private _targetVout: number;\r\n  private _sig: Sig | null;\r\n\r\n  constructor(\r\n    transaction: Transaction,\r\n    targetVout: number = 0,\r\n    sigmaInstance: number = 0,\r\n    refVin: number = 0\r\n  ) {\r\n    this._transaction = transaction;\r\n    this._targetVout = targetVout;\r\n    this._refVin = refVin;\r\n    this._sigmaInstance = sigmaInstance;\r\n    this._sig = this.sig;\r\n    this.setHashes();\r\n  }\r\n\r\n  setHashes = () => {\r\n    this._inputHash = this.getInputHash();\r\n    this._dataHash = this.getDataHash();\r\n  };\r\n\r\n  setTargetVout = (targetVout: number) => {\r\n    this._targetVout = targetVout;\r\n  };\r\n\r\n  setSigmaInstance = (sigmaInstance: number) => {\r\n    this._sigmaInstance = sigmaInstance;\r\n  };\r\n\r\n  getMessageHash(): Hash {\r\n    if (!this._inputHash || !this._dataHash) {\r\n      throw new Error(\"Input hash and data hash must be set\");\r\n    }\r\n\r\n    const inputBytes = this._inputHash.to_bytes();\r\n    const dataBytes = this._dataHash.to_bytes();\r\n    const combinedHashes = new Uint8Array(inputBytes.length + dataBytes.length);\r\n    combinedHashes.set(inputBytes, 0);\r\n    combinedHashes.set(dataBytes, inputBytes.length);\r\n\r\n    return Hash.sha_256(combinedHashes);\r\n  }\r\n\r\n  get transaction(): Transaction {\r\n    return this._transaction;\r\n  }\r\n\r\n  _sign(signature: Signature, address: string) {\r\n    const vin = this._refVin === -1 ? this._targetVout : this._refVin;\r\n    const signedAsm = `${sigmaHex} ${Buffer.from(\r\n      Algorithm.BSM,\r\n      \"utf-8\"\r\n    ).toString(\"hex\")} ${Buffer.from(address, \"utf-8\").toString(\r\n      \"hex\"\r\n    )} ${signature.to_compact_hex()} ${Buffer.from(\r\n      vin.toString(),\r\n      \"utf-8\"\r\n    ).toString(\"hex\")}`;\r\n\r\n    const sigmaScript = Script.from_asm_string(signedAsm);\r\n\r\n    this._sig = {\r\n      algorithm: Algorithm.BSM,\r\n      address: address,\r\n      signature: Buffer.from(signature.to_compact_bytes()).toString(\"base64\"),\r\n      vin,\r\n      targetVout: this._targetVout,\r\n    };\r\n\r\n    let existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const containsOpReturn = existingAsm?.split(\" \").includes(\"OP_RETURN\");\r\n    const separator = containsOpReturn ? \"7c\" : \"OP_RETURN\";\r\n\r\n    let newScriptAsm = \"\";\r\n\r\n    const existingSig = this.sig;\r\n\r\n    // sigmaIndex is 0 based while count is 1 based\r\n    if (existingSig && this._sigmaInstance === this.getSigInstanceCount()) {\r\n      // Replace the existing signature\r\n      const scriptChunks = existingAsm?.split(\" \") || [];\r\n      const sigIndex = this.getSigInstancePosition();\r\n\r\n      const newSignedAsmChunks = signedAsm.split(\" \");\r\n      if (sigIndex !== -1) {\r\n        existingAsm = scriptChunks\r\n          .splice(sigIndex, 5, ...newSignedAsmChunks)\r\n          .join(\"\");\r\n      }\r\n    }\r\n    // Append the new signature\r\n    newScriptAsm = `${existingAsm} ${separator} ${signedAsm}`;\r\n\r\n    const newScript = Script.from_asm_string(newScriptAsm);\r\n    const signedTx = Transaction.from_bytes(this._transaction.to_bytes());\r\n    const signedTxOut = new TxOut(this.targetTxOut!.get_satoshis(), newScript);\r\n    signedTx.set_output(this._targetVout, signedTxOut);\r\n\r\n    // update the object state\r\n    this._transaction = signedTx;\r\n\r\n    return {\r\n      sigmaScript,\r\n      signedTx,\r\n      ...this._sig,\r\n    };\r\n  }\r\n  // Sign with Sigma protocol\r\n  // privateKey: a bsv-wasm PrivateKey\r\n  // inputs: either an array of TxIn from bsv-wasm or an array o string txids\r\n  //    must be in the same order they are added to the transaction\r\n  //    adding input txids to the signature scheme eliminates replay attacks\r\n  // dataHash: a sha256 hash of the data to be signed\r\n  //     it should include all the data in the output script prior to the \"SIGMA\" protocol instance\r\n  //     excluding the \"|\" protocol separator and \"SIGMA\" prefix itself\r\n  sign(privateKey: PrivateKey): SignResponse {\r\n    const message = this.getMessageHash();\r\n\r\n    let signature = BSM.sign_message(privateKey, message.to_bytes());\r\n\r\n    const address = P2PKHAddress.from_pubkey(\r\n      privateKey.to_public_key()\r\n    ).to_string();\r\n\r\n    return this._sign(signature, address);\r\n  }\r\n\r\n  async remoteSign(\r\n    keyHost: string,\r\n    authToken?: AuthToken\r\n  ): Promise<SignResponse> {\r\n    const headers = authToken\r\n      ? {\r\n          [authToken?.key]: authToken?.value,\r\n        }\r\n      : {};\r\n\r\n    try {\r\n      const response = await axios.post(\r\n        `${keyHost}/sign${\r\n          authToken?.type === \"query\"\r\n            ? \"?\" + authToken?.key + \"=\" + authToken?.value\r\n            : \"\"\r\n        }`,\r\n        {\r\n          message: this.getMessageHash().to_hex(),\r\n          encoding: \"hex\",\r\n        },\r\n        {\r\n          headers: {\r\n            ...headers,\r\n            \"Content-Type\": \"application/json\",\r\n            Accept: \"application/json\",\r\n          },\r\n        }\r\n      );\r\n      const { address, message, sig } = response.data as RemoteSigningResponse;\r\n\r\n      const signature = Signature.from_compact_bytes(\r\n        Buffer.from(sig, \"base64\")\r\n      );\r\n      return this._sign(signature, address);\r\n    } catch (error: any) {\r\n      console.log(error);\r\n      // handle error\r\n      throw new Error(error.response);\r\n    }\r\n  }\r\n\r\n  verify = () => {\r\n    if (!this.sig) {\r\n      throw new Error(\"No signature data provided\");\r\n    }\r\n    if (!this.getMessageHash()) {\r\n      throw new Error(\"No tx data provided\");\r\n    }\r\n\r\n    const p2pkhAddress = P2PKHAddress.from_string(this.sig.address);\r\n    const signature = Signature.from_compact_bytes(\r\n      Buffer.from(this.sig.signature, \"base64\")\r\n    );\r\n\r\n    return p2pkhAddress.verify_bitcoin_message(\r\n      this.getMessageHash().to_bytes(),\r\n      signature\r\n    );\r\n  };\r\n\r\n  getInputHash = (): Hash => {\r\n    // if vin is -1, we're signing the corresponding input\r\n    // so we use this._targetVout as the vin\r\n    // this allows for better compatibility with partially signed transactions\r\n    // where the anchor input index is not known\r\n    const vin = this._refVin === -1 ? this._targetVout : this._refVin;\r\n    return this._getInputHashByVin(vin);\r\n  };\r\n\r\n  private _getInputHashByVin = (vin: number): Hash => {\r\n    const txIn = this._transaction.get_input(vin);\r\n    if (txIn) {\r\n      return Hash.sha_256(txIn.get_outpoint_bytes());\r\n    }\r\n    // using dummy hash\r\n    return Hash.sha_256(new Uint8Array(32));\r\n  };\r\n\r\n  // gets the Hash.sha256 for a given sigma instance within an output script\r\n  // an example of 2 instances would be a user signature followed by a platform signature\r\n  getDataHash = (): Hash => {\r\n    if (!this._transaction) {\r\n      throw new Error(\"No transaction provided\");\r\n    }\r\n    const outputScript = this._transaction\r\n      ?.get_output(this._targetVout)\r\n      ?.get_script_pub_key();\r\n\r\n    const scriptChunks = outputScript?.to_asm_string().split(\" \") || [];\r\n\r\n    // loop over the script chunks and set the endIndex when the nTh instance is found\r\n    let occurances = 0;\r\n    for (let i = 0; i < scriptChunks.length; i++) {\r\n      if (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\r\n        if (occurances === this._sigmaInstance) {\r\n          // the -1 is to account for either the OP_RETURN\r\n          // or \"|\" separator which is not signed\r\n          const dataChunks = scriptChunks.slice(0, i - 1);\r\n          const dataScript = Script.from_asm_string(dataChunks.join(\" \"));\r\n          return Hash.sha_256(dataScript.to_bytes());\r\n        }\r\n        occurances++;\r\n      }\r\n    }\r\n\r\n    // If no endIndex found, return the hash for the entire script\r\n    const dataScript = Script.from_asm_string(scriptChunks.join(\" \"));\r\n    return Hash.sha_256(dataScript.to_bytes());\r\n  };\r\n\r\n  get targetTxOut(): TxOut | null {\r\n    return this._transaction?.get_output(this._targetVout) || null;\r\n  }\r\n\r\n  // get the signature from the selected sigma instance\r\n  get sig(): Sig | null {\r\n    const output = this._transaction.get_output(this._targetVout);\r\n    const outputScript = output?.get_script_pub_key();\r\n\r\n    const scriptChunks = outputScript?.to_asm_string().split(\" \") || [];\r\n    const instances: Sig[] = [];\r\n\r\n    for (let i = 0; i < scriptChunks.length; i++) {\r\n      if (scriptChunks[i].toUpperCase() === sigmaHex.toUpperCase()) {\r\n        const sig = {\r\n          algorithm: Buffer.from(scriptChunks[i + 1], \"hex\").toString(\"utf-8\"),\r\n          address: Buffer.from(scriptChunks[i + 2], \"hex\").toString(\"utf-8\"),\r\n          signature: Buffer.from(scriptChunks[i + 3], \"hex\").toString(\"base64\"),\r\n          vin: parseInt(\r\n            Buffer.from(scriptChunks[i + 4], \"hex\").toString(\"utf-8\")\r\n          ),\r\n        } as Sig;\r\n\r\n        instances.push(sig);\r\n\r\n        // fast forward to the next possible instance position\r\n        // 3 fields + 1 extra for the \"|\" separator\r\n        i += 4;\r\n      }\r\n    }\r\n    return instances.length === 0 ? this._sig : instances[this._sigmaInstance];\r\n  }\r\n\r\n  getSigInstanceCount(): number {\r\n    const existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const scriptChunks = existingAsm?.split(\" \") || [];\r\n    return scriptChunks.filter(\r\n      (chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase()\r\n    ).length;\r\n  }\r\n\r\n  getSigInstancePosition(): number {\r\n    const existingAsm = this.targetTxOut?.get_script_pub_key().to_asm_string();\r\n    const scriptChunks = existingAsm?.split(\" \") || [];\r\n    return scriptChunks.findIndex(\r\n      (chunk) => chunk.toUpperCase() === sigmaHex.toUpperCase()\r\n    );\r\n  }\r\n}\r\n"],"names":["sigmaHex","Algorithm","Sigma","constructor","transaction","targetVout","sigmaInstance","refVin","_inputHash","_dataHash","this","_transaction","_sigmaInstance","_refVin","_targetVout","_sig","setHashes","getInputHash","getDataHash","setTargetVout","setSigmaInstance","verify","sig","Error","getMessageHash","p2pkhAddress","P2PKHAddress","from_string","address","signature","Signature","from_compact_bytes","Buffer","from","verify_bitcoin_message","to_bytes","_getInputHashByVin","vin","txIn","get_input","Hash","sha_256","get_outpoint_bytes","Uint8Array","_this$_transaction","_this$_transaction$ge","outputScript","get_output","get_script_pub_key","scriptChunks","to_asm_string","split","occurances","i","length","toUpperCase","dataChunks","slice","dataScript","Script","from_asm_string","join","inputBytes","dataBytes","combinedHashes","set","_sign","_this$targetTxOut","_existingAsm","signedAsm","BSM","toString","to_compact_hex","sigmaScript","algorithm","to_compact_bytes","existingAsm","targetTxOut","separator","includes","newScriptAsm","getSigInstanceCount","_existingAsm2","sigIndex","getSigInstancePosition","newSignedAsmChunks","splice","newScript","signedTx","Transaction","from_bytes","signedTxOut","TxOut","get_satoshis","set_output","_extends","sign","privateKey","message","sign_message","from_pubkey","to_public_key","to_string","async","keyHost","authToken","headers","key","value","response","axios","post","type","to_hex","encoding","Accept","data","error","console","log","_this$_transaction2","output","instances","parseInt","push","_this$targetTxOut2","filter","chunk","_this$targetTxOut3","findIndex"],"mappings":"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"}