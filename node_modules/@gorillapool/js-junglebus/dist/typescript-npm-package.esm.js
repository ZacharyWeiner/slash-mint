import Centrifuge from 'centrifuge/build/protobuf';
import Queue from 'better-queue';
import protobuf from 'protobufjs';
import 'cross-fetch/polyfill';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var ControlMessageStatusCode;
(function (ControlMessageStatusCode) {
    ControlMessageStatusCode[ControlMessageStatusCode["WAITING"] = 100] = "WAITING";
    ControlMessageStatusCode[ControlMessageStatusCode["ERROR"] = 101] = "ERROR";
    ControlMessageStatusCode[ControlMessageStatusCode["PAUSED"] = 102] = "PAUSED";
    ControlMessageStatusCode[ControlMessageStatusCode["BLOCK_DONE"] = 200] = "BLOCK_DONE";
    ControlMessageStatusCode[ControlMessageStatusCode["REORG"] = 300] = "REORG";
})(ControlMessageStatusCode || (ControlMessageStatusCode = {}));

const ProtobufDef = {
    nested: {
        Transaction: {
            fields: {
                id: {
                    type: "string",
                    id: 1,
                },
                block_hash: {
                    type: "string",
                    id: 2,
                },
                block_height: {
                    type: "uint32",
                    id: 3,
                },
                block_index: {
                    type: "uint64",
                    id: 4,
                },
                block_time: {
                    type: "uint32",
                    id: 5,
                },
                transaction: {
                    type: "bytes",
                    id: 6,
                },
                merkle_proof: {
                    type: "bytes",
                    id: 7,
                },
            }
        },
        ControlResponse: {
            fields: {
                statusCode: {
                    type: "uint32",
                    id: 1,
                },
                status: {
                    type: "string",
                    id: 2,
                },
                message: {
                    type: "string",
                    id: 3,
                },
                block: {
                    type: "uint32",
                    id: 4,
                },
                transactions: {
                    type: "uint64",
                    id: 5,
                }
            }
        }
    }
};
const ProtobufRoot = protobuf.Root.fromJSON(ProtobufDef);

/**
 * JungleBusSubscription class
 *
 * @constructor
 * @example
 * const jungleBusClient = new JungleBusSubscription(options: Subscription)
 */
class JungleBusSubscription {
    constructor(client, subscriptionID, fromBlock, onPublish, onStatus, onError, onMempool) {
        // Set the max size of the internal queue, before pausing the subscription to be able to catch up
        // this doesn't use a lot of RAM
        this.MaxQueueSize = 20000;
        this.paused = false;
        this.client = client;
        this.subscriptionID = subscriptionID;
        this.currentBlock = fromBlock;
        this.onPublish = onPublish;
        this.onMempool = onMempool;
        this.onStatus = onStatus;
        this.onError = onError;
        this.subscribed = false;
        this.controlSubscribed = false;
        this.mempoolSubscribed = false;
        this.subscriptionQueue = new Queue(function (tx, cb) {
            return __awaiter(this, void 0, void 0, function* () {
                if (tx.statusCode) {
                    if (onStatus) {
                        yield onStatus(tx);
                    }
                }
                else {
                    if (onPublish) {
                        yield onPublish(tx);
                    }
                }
                cb(null, true);
            });
        });
        this.mempoolQueue = new Queue(function (tx, cb) {
            return __awaiter(this, void 0, void 0, function* () {
                if (onMempool) {
                    yield onMempool(tx);
                }
                cb(null, true);
            });
        });
        this.Subscribe();
    }
    /**
     * Start the subscription
     *
     * @return void
     */
    Subscribe() {
        if (this.subscription || this.controlSubscription || this.mempoolSubscription) {
            // if the subscriptions are active, unsubscribe and then re-subscribe
            this.UnSubscribe();
        }
        if (this.onMempool) {
            this.subscribeMempool();
        }
        if (this.onPublish) {
            this.subscribeControlMessage();
            this.subscribeTransactionBlocks();
        }
    }
    subscribeControlMessage() {
        const self = this;
        const controlChannel = `query:${self.subscriptionID}:control`;
        this.controlSubscription = this.client.centrifuge.newSubscription(controlChannel);
        this.controlSubscription.on('publication', (ctx) => {
            let message;
            if (this.client.protocol === "protobuf") {
                const Message = ProtobufRoot.lookupType("ControlResponse");
                message = Message.decode(ctx.data);
            }
            else {
                message = ctx.data;
            }
            if (message.statusCode === ControlMessageStatusCode.ERROR) {
                if (self.onError) {
                    self.onError({
                        channel: ctx.channel,
                        type: message.status,
                        error: {
                            code: message.statusCode,
                            message: message.status
                        },
                    });
                }
            }
            else {
                if (message.statusCode === ControlMessageStatusCode.BLOCK_DONE) {
                    this.currentBlock = message.block;
                }
                if (this.onStatus) {
                    this.subscriptionQueue.push(message);
                }
            }
        })
            .on("subscribed", function (ctx) {
            self.controlSubscribed = true;
        })
            .on("error", function (error) {
            self.error = error;
            if (self.onError) {
                self.onError(error);
            }
        });
        this.controlSubscription.subscribe();
    }
    subscribeMempool() {
        const self = this;
        const mempoolChannel = `query:${self.subscriptionID}:mempool`;
        this.mempoolSubscription = self.client.centrifuge.newSubscription(mempoolChannel);
        this.mempoolSubscription.on('publication', (ctx) => {
            if (this.onMempool) {
                const tx = this.processTransaction(self, ctx);
                this.mempoolQueue.push(tx);
            }
        })
            .on("subscribed", function (ctx) {
            self.mempoolSubscribed = true;
        })
            .on("error", function (error) {
            self.error = error;
            if (self.onError) {
                self.onError(error);
            }
        });
        this.mempoolSubscription.subscribe();
    }
    subscribeTransactionBlocks() {
        var _a;
        const channel = `query:${this.subscriptionID}:${this.currentBlock}`;
        let pauseTimeOut;
        const self = this;
        this.subscription = self.client.centrifuge.newSubscription(channel);
        this.paused = false;
        function pauseProcessing() {
            return setTimeout(() => {
                var _a;
                // @ts-ignore
                const queueLength = self.subscriptionQueue.length;
                if (queueLength < self.MaxQueueSize / 2) {
                    (_a = self.subscription) === null || _a === void 0 ? void 0 : _a.publish({ cmd: 'start' });
                    self.paused = false;
                }
                else {
                    pauseTimeOut = pauseProcessing();
                }
            }, 2000);
        }
        this.subscription
            .on('publication', (ctx) => {
            var _a;
            if (this.onPublish) {
                const tx = self.processTransaction(self, ctx);
                this.subscriptionQueue.push(tx);
                // @ts-ignore
                const queueLength = self.subscriptionQueue.length;
                if (queueLength > self.MaxQueueSize) {
                    if (!self.paused) {
                        (_a = self.subscription) === null || _a === void 0 ? void 0 : _a.publish({ cmd: 'pause' });
                        self.paused = true;
                        if (self.onStatus) {
                            self.onStatus({
                                statusCode: ControlMessageStatusCode.PAUSED,
                                status: "paused subscription",
                                message: "paused subscription to catch up",
                            });
                        }
                    }
                    if (pauseTimeOut) {
                        clearTimeout(pauseTimeOut);
                    }
                    pauseTimeOut = pauseProcessing();
                }
            }
        })
            .on("subscribed", function (ctx) {
            self.subscribed = true;
        })
            .on("state", function (ctx) {
            var _a;
            if (ctx.oldState === "subscribed" && ctx.newState === "subscribing") {
                // make sure we are subscribing to the correct channel
                const ch = ctx.channel.split(":");
                if (((_a = ch[2]) === null || _a === void 0 ? void 0 : _a.match(/^\d+$/)) && Number(ch[2]) !== self.currentBlock) {
                    // reset this subscription to set the correct block height
                    self.unsubscribeTransactionBlocks();
                    self.subscribeTransactionBlocks();
                }
            }
        })
            .on("error", function (error) {
            self.error = error;
            if (self.onError) {
                self.onError(error);
            }
        });
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.subscribe();
    }
    processTransaction(self, ctx) {
        if (self.client.protocol === "protobuf") {
            const Message = ProtobufRoot.lookupType("Transaction");
            const message = Message.decode(ctx.data);
            return Object.assign(Object.assign({}, message), { transaction: toHexString(message.transaction), 
                // merkle proofs are missing from mempool transactions
                merkle_proof: message.merkle_proof ? toHexString(message.merkle_proof) : '' });
        }
        else {
            return Object.assign(Object.assign({}, ctx.data), { 
                // transactions can be missing, which means they are stored in S3
                transaction: ctx.data.transaction ? typeof Buffer !== "undefined" ? Buffer.from(ctx.data.transaction, 'base64').toString('hex') : base64ToHex(ctx.data.transaction) : '', 
                // merkle proofs are missing from mempool transactions
                merkle_proof: ctx.data.merkle_proof ? (typeof Buffer !== "undefined" ? Buffer.from(ctx.data.merkle_proof, 'base64').toString('hex') : base64ToHex(ctx.data.merkle_proof)) : '' });
        }
    }
    /**
     * Get the current last block that was processed completely
     *
     * @return number
     */
    GetCurrentBlock() {
        return this.currentBlock;
    }
    /**
     * Unsubscribe from this subscription
     *
     * @return void
     */
    UnSubscribe() {
        if (this.subscription) {
            this.unsubscribeTransactionBlocks();
        }
        if (this.mempoolSubscription) {
            this.mempoolSubscription.unsubscribe();
            this.mempoolSubscription.removeAllListeners();
            this.client.centrifuge.removeSubscription(this.mempoolSubscription);
            this.mempoolSubscription = undefined;
            this.mempoolSubscribed = false;
        }
        if (this.controlSubscription) {
            this.controlSubscription.unsubscribe();
            this.controlSubscription.removeAllListeners();
            this.client.centrifuge.removeSubscription(this.controlSubscription);
            this.controlSubscription = undefined;
            this.controlSubscribed = false;
        }
    }
    unsubscribeTransactionBlocks() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription.removeAllListeners();
            this.client.centrifuge.removeSubscription(this.subscription);
            this.subscription = undefined;
            this.subscribed = false;
        }
    }
}
function toHexString(byteArray) {
    return Array.from(byteArray, function (byte) {
        return ('0' + (byte & 0xFF).toString(16)).slice(-2);
    }).join('').toLowerCase();
}
function base64ToHex(str) {
    const raw = atob(str);
    let result = '';
    for (let i = 0; i < raw.length; i++) {
        const hex = raw.charCodeAt(i).toString(16);
        result += (hex.length === 2 ? hex : '0' + hex);
    }
    return result.toLowerCase();
}

let ws;
if (typeof window === "undefined") {
    ws = require('ws');
}
/**
 * JungleBusClient class
 *
 * @constructor
 * @example
 * const jungleBusClient = new JungleBusClient(<serverUrl>, {
 *   protocol: 'protobuf',
 * })
 */
class JungleBusClient {
    constructor(serverUrl, options) {
        this.client = (options || {});
        if (!this.client.protocol) {
            this.client.protocol = 'json';
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.useSSL) === "undefined") {
            this.client.useSSL = !(serverUrl.match(/^http:/) || serverUrl.match(/^ws:/));
        }
        // remove https / wss from server url is defined
        this.client.serverUrl = serverUrl.replace(/^https?:\/\//, '').replace(/^wss?:\/\//, '');
    }
    /**
     * Login to the JungleBus server and get a token
     *
     * @param username
     * @param password
     * @return error | null
     */
    Login(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(`${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/user/login`, {
                    method: 'POST',
                    headers: {
                        "content-type": "application/json"
                    },
                    body: JSON.stringify({
                        username,
                        password,
                    })
                });
                if (response.status !== 200) {
                    this.client.error = new Error(response.statusText);
                    return null;
                }
                const body = yield response.json();
                this.SetToken(body.token);
                return null;
            }
            catch (e) {
                this.client.error = e;
                return e;
            }
        });
    }
    getToken() {
        return this.client.token;
    }
    /**
     * Set the JWT token to use in all calls
     *
     * @param token string
     * @constructor
     */
    SetToken(token) {
        return this.client.token = token;
    }
    /**
     * Get an anonymous token based on a subscription ID to the JungleBus server
     *
     * @param subscriptionId
     * @return error | null
     */
    GetTokenFromSubscription(subscriptionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(`${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/user/subscription-token`, {
                    method: 'POST',
                    headers: {
                        "content-type": "application/json"
                    },
                    body: JSON.stringify({
                        id: subscriptionId,
                    })
                });
                if (response.status !== 200) {
                    this.client.error = new Error(response.statusText);
                    return null;
                }
                const body = yield response.json();
                this.SetToken(body.token);
                return null;
            }
            catch (e) {
                this.client.error = e;
                return e;
            }
        });
    }
    /**
     * Return the last error thrown
     *
     * @return Error
     */
    GetLastError() {
        var _a;
        return (_a = this.client) === null || _a === void 0 ? void 0 : _a.error;
    }
    /**
     * Create the connection to the JungleBus server
     *
     * @return void
     */
    Connect() {
        const self = this;
        const client = this.client;
        client.centrifuge = new Centrifuge(`${this.client.useSSL ? 'wss' : 'ws'}://${client.serverUrl}/connection/websocket${(client.protocol === "protobuf" ? '?format=protobuf' : '')}`, {
            protocol: client.protocol,
            debug: client.debug,
            websocket: typeof window !== "undefined" ? window.WebSocket : ws,
            timeout: 5000,
            maxServerPingDelay: 30000,
            getToken: function () {
                return new Promise((resolve, reject) => {
                    fetch(`${client.useSSL ? 'https' : 'http'}://${client.serverUrl}/v1/user/refresh-token`, {
                        headers: {
                            token: self.getToken() || '',
                        }
                    })
                        .then(res => {
                        if (!res.ok) {
                            throw new Error(`Unexpected status code ${res.status}`);
                        }
                        return res.json();
                    })
                        .then(data => {
                        // update the token
                        self.SetToken(data.token);
                        resolve(data.token);
                    })
                        .catch(err => {
                        reject(err);
                    });
                });
            },
        });
        if (client.onConnected) {
            client.centrifuge.on('connected', client.onConnected);
        }
        if (client.onConnecting) {
            client.centrifuge.on('connecting', client.onConnecting);
        }
        if (client.onDisconnected) {
            client.centrifuge.on('disconnected', client.onDisconnected);
        }
        if (client.onError) {
            client.centrifuge.on('error', client.onError);
        }
        client.centrifuge.connect();
    }
    /**
     * Disconnect the client from the server
     *
     * @return void
     */
    Disconnect() {
        this.client.centrifuge.disconnect();
    }
    /**
     * Subscribe to a channel on the JungleBus server
     *
     * @param subscriptionID
     * @param fromBlock
     * @param onPublish
     * @param onStatus
     * @param onError
     * @param onMempool
     * @return JungleBusSubscription
     */
    Subscribe(subscriptionID, fromBlock, onPublish, onStatus, onError, onMempool) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client.token) {
                // we do not have a token yet, sign in anonymously with the subscription id
                yield this.GetTokenFromSubscription(subscriptionID);
            }
            // Connect to the backend, if we do not have a connection yet
            if (!this.client.centrifuge) {
                this.Connect();
            }
            return new JungleBusSubscription(this.client, subscriptionID, fromBlock, onPublish, onStatus, onError, onMempool);
        });
    }
    /**
     *  Get a transaction from the JungleBus API
     *
     * @param txId Transaction ID in hex
     * @return Promise<Transaction> | null
     */
    GetTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/transaction/get/${txId}`;
            return yield this.apiRequest(url);
        });
    }
    /**
     *  Get block header info from JungleBus
     *
     * @param block Block header height or hash
     * @return Promise<BlockHeader> | null
     */
    GetBlockHeader(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/block_header/get/${block}`;
            return yield this.apiRequest(url);
        });
    }
    /**
     *  Get a list of block headers from JungleBus
     *
     * @param fromBlock Block header height or hash
     * @param limit Limit the number of results to this number (max 10,000)
     * @return Promise<BlockHeader> | null
     */
    GetBlockHeaders(fromBlock, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/block_header/list/${fromBlock}?limit=${limit}`;
            return yield this.apiRequest(url);
        });
    }
    /**
     *  Get all transaction references for the given address
     *
     * @param address Bitcoin address
     * @return Promise<BlockHeader> | null
     */
    GetAddressTransactions(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/address/get/${address}`;
            return yield this.apiRequest(url);
        });
    }
    /**
     *  Get all transactions, including the hex and merkle proof, for the given address
     *
     *  This function is much slower than GetAddressTransactions
     *
     * @param address Bitcoin address
     * @return Promise<BlockHeader> | null
     */
    GetAddressTransactionDetails(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.client.useSSL ? 'https' : 'http'}://${this.client.serverUrl}/v1/address/transactions/${address}`;
            return yield this.apiRequest(url);
        });
    }
    apiRequest(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(url, {
                    method: 'GET',
                    headers: {
                        "content-type": "application/json",
                        token: this.getToken() || '',
                    },
                });
                if (response.status !== 200) {
                    this.client.error = new Error(response.statusText);
                    return null;
                }
                return yield response.json();
            }
            catch (e) {
                this.client.error = e;
                throw e;
            }
        });
    }
}

export { ControlMessageStatusCode, JungleBusClient, JungleBusSubscription };
//# sourceMappingURL=typescript-npm-package.esm.js.map
