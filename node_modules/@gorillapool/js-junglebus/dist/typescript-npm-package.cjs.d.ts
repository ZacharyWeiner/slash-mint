import { Centrifuge, ConnectingContext, DisconnectedContext, ConnectedContext, ErrorContext, Subscription, SubscriptionErrorContext, PublicationContext } from 'centrifuge';
import protobuf from 'protobufjs';

interface Client {
    centrifuge: Centrifuge;
    serverUrl: string;
    protocol: "protobuf" | "json" | undefined;
    useSSL?: boolean;
    token?: string;
    onConnecting?: (ctx: ConnectingContext) => void;
    onDisconnected?: (ctx: DisconnectedContext) => void;
    onConnected?: (ctx: ConnectedContext) => void;
    onError?: (ctx: ErrorContext) => void;
    debug?: boolean;
    error?: Error;
}
interface PaymentRequest {
    tx: string;
}
interface ClientOptions {
    protocol: "protobuf" | "json" | undefined;
    useSSL?: boolean;
    token?: string;
    onConnecting?: (ctx: ConnectingContext) => void;
    onDisconnected?: (ctx: DisconnectedContext) => void;
    onConnected?: (ctx: ConnectedContext) => void;
    onError?: (ctx: ErrorContext) => void;
    onPayment?: (request: PaymentRequest) => void;
    debug?: boolean;
}
interface Address {
    id: string;
    address: string;
    transaction_id: string;
    block_hash: string;
    transaction_num: number;
}
interface BlockHeader {
    hash: string;
    coin: number;
    height: number;
    time: number;
    nonce: number;
    version: number;
    merkleroot: string;
    bits: string;
    synced: number;
}
interface Transaction {
    id: string;
    block_hash: string;
    block_height: number;
    block_index: number;
    block_time: number;
    transaction: string;
    merkle_proof: string;
}
interface TransactionMessage {
    id: string;
    block_hash: string;
    block_height: number;
    block_index: number;
    block_time: number;
    transaction: protobuf.Buffer;
    merkle_proof: protobuf.Buffer;
}
declare enum ControlMessageStatusCode {
    WAITING = 100,
    ERROR = 101,
    PAUSED = 102,
    BLOCK_DONE = 200,
    REORG = 300
}
interface ControlMessage {
    statusCode: ControlMessageStatusCode;
    status: string;
    message: string;
    block: number;
    transactions: number;
}

/**
 * JungleBusSubscription class
 *
 * @constructor
 * @example
 * const jungleBusClient = new JungleBusSubscription(options: Subscription)
 */
declare class JungleBusSubscription {
    MaxQueueSize: number;
    client: Client;
    subscription: Subscription | undefined;
    controlSubscription: Subscription | undefined;
    mempoolSubscription: Subscription | undefined;
    subscriptionID: string;
    currentBlock: number;
    onPublish?: (tx: Transaction) => void;
    onMempool?: (tx: Transaction) => void;
    onStatus?: (message: ControlMessage) => void;
    onError?: (error: SubscriptionErrorContext) => void;
    subscribed: boolean;
    controlSubscribed: boolean;
    mempoolSubscribed: boolean;
    paused: boolean;
    error: SubscriptionErrorContext | undefined;
    private subscriptionQueue;
    private mempoolQueue;
    constructor(client: Client, subscriptionID: string, fromBlock: number, onPublish?: (tx: Transaction) => void, onStatus?: (message: ControlMessage) => void, onError?: (error: SubscriptionErrorContext) => void, onMempool?: (tx: Transaction) => void);
    /**
     * Start the subscription
     *
     * @return void
     */
    Subscribe(): void;
    private subscribeControlMessage;
    private subscribeMempool;
    private subscribeTransactionBlocks;
    protected processTransaction(self: this, ctx: PublicationContext): any;
    /**
     * Get the current last block that was processed completely
     *
     * @return number
     */
    GetCurrentBlock(): number;
    /**
     * Unsubscribe from this subscription
     *
     * @return void
     */
    UnSubscribe(): void;
    private unsubscribeTransactionBlocks;
}

/**
 * JungleBusClient class
 *
 * @constructor
 * @example
 * const jungleBusClient = new JungleBusClient(<serverUrl>, {
 *   protocol: 'protobuf',
 * })
 */
declare class JungleBusClient {
    client: Client;
    constructor(serverUrl: string, options?: ClientOptions);
    /**
     * Login to the JungleBus server and get a token
     *
     * @param username
     * @param password
     * @return error | null
     */
    Login(username: string, password: string): Promise<Error | null>;
    private getToken;
    /**
     * Set the JWT token to use in all calls
     *
     * @param token string
     * @constructor
     */
    SetToken(token: string): string;
    /**
     * Get an anonymous token based on a subscription ID to the JungleBus server
     *
     * @param subscriptionId
     * @return error | null
     */
    GetTokenFromSubscription(subscriptionId: string): Promise<Error | null>;
    /**
     * Return the last error thrown
     *
     * @return Error
     */
    GetLastError(): Error | undefined;
    /**
     * Create the connection to the JungleBus server
     *
     * @return void
     */
    Connect(): void;
    /**
     * Disconnect the client from the server
     *
     * @return void
     */
    Disconnect(): void;
    /**
     * Subscribe to a channel on the JungleBus server
     *
     * @param subscriptionID
     * @param fromBlock
     * @param onPublish
     * @param onStatus
     * @param onError
     * @param onMempool
     * @return JungleBusSubscription
     */
    Subscribe(subscriptionID: string, fromBlock: number, onPublish?: (tx: Transaction) => void, onStatus?: (message: ControlMessage) => void, onError?: (error: SubscriptionErrorContext) => void, onMempool?: (tx: Transaction) => void): Promise<JungleBusSubscription>;
    /**
     *  Get a transaction from the JungleBus API
     *
     * @param txId Transaction ID in hex
     * @return Promise<Transaction> | null
     */
    GetTransaction(txId: string): Promise<Transaction | null>;
    /**
     *  Get block header info from JungleBus
     *
     * @param block Block header height or hash
     * @return Promise<BlockHeader> | null
     */
    GetBlockHeader(block: string | number): Promise<BlockHeader | null>;
    /**
     *  Get a list of block headers from JungleBus
     *
     * @param fromBlock Block header height or hash
     * @param limit Limit the number of results to this number (max 10,000)
     * @return Promise<BlockHeader> | null
     */
    GetBlockHeaders(fromBlock: string | number, limit: number): Promise<BlockHeader[] | null>;
    /**
     *  Get all transaction references for the given address
     *
     * @param address Bitcoin address
     * @return Promise<BlockHeader> | null
     */
    GetAddressTransactions(address: string): Promise<Address[] | null>;
    /**
     *  Get all transactions, including the hex and merkle proof, for the given address
     *
     *  This function is much slower than GetAddressTransactions
     *
     * @param address Bitcoin address
     * @return Promise<BlockHeader> | null
     */
    GetAddressTransactionDetails(address: string): Promise<Address[] | null>;
    private apiRequest;
}

export { Client, ClientOptions, ControlMessage, ControlMessageStatusCode, JungleBusClient, JungleBusSubscription, Transaction, TransactionMessage };
